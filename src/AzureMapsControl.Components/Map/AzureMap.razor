@namespace AzureMapsControl.Components.Map

@using AzureMapsControl.Components.Atlas
@using AzureMapsControl.Components.Configuration
@using AzureMapsControl.Components.Logger

@using Microsoft.JSInterop
@using Microsoft.Extensions.Options

@inject IOptions<AzureMapsConfiguration> Configuration
@inject IMapAdderService MapService
@inject IJSRuntime JSRuntime
@inject Microsoft.Extensions.Logging.ILogger<AzureMap> Logger

<div id="@Id"></div>

@code {

    #region Fields

    private MapEventInvokeHelper _mapEventInvokeHelper;
    private Markers.HtmlMarkerInvokeHelper _htmlMarkerEventInvokeHelper;
    private Drawing.DrawingToolbarEventInvokeHelper _drawingToolbarEventInvokeHelper;
    private Layers.LayerEventInvokeHelper _layerEventInvokeHelper;
    private Popups.PopupInvokeHelper _popupInvokeHelper;

    private string _id;

    #endregion

    #region Parameters

    /// <summary>
    /// The options for setting the map control's camera.
    /// </summary>
    [Parameter]
    public CameraOptions CameraOptions { get; set; } = new CameraOptions();

    /// <summary>
    /// Options for the map's style.
    /// </summary>
    [Parameter]
    public StyleOptions StyleOptions { get; set; } = new StyleOptions();

    /// <summary>
    /// Options for enabling/disabling user interaction with the map.
    /// </summary>
    [Parameter]
    public UserInteractionOptions UserInteractionOptions { get; set; } = new UserInteractionOptions();

    /// <summary>
    /// Global properties used in all atlas service requests.
    /// </summary>
    [Parameter]
    public ServiceOptions ServiceOptions { get; set; } = new ServiceOptions();

    /// <summary>
    /// Id affected to the div hosting the map
    /// </summary>
    [Parameter]
    public string Id
    {
        get => _id;
        set { if (string.IsNullOrWhiteSpace(value)) { throw new ArgumentException("ID on the map is mandatory"); } _id = value; }
    }

    /// <summary>
    /// Defines the events which needs to be activated
    /// </summary>
    [Parameter]
    public MapEventActivationFlags EventActivationFlags { get; set; }

    /// <summary>
    /// Defines the controls to add to the map when it is ready
    /// </summary>
    [Parameter]
    public IReadOnlyCollection<Control> Controls { get; set; }

    /// <summary>
    /// HtmlMarkers to add to the map when it is ready
    /// </summary>
    [Parameter]
    public IReadOnlyCollection<AzureMapsControl.Components.Markers.HtmlMarker> HtmlMarkers { get; set; }

    /// <summary>
    /// Options to display traffic on the map
    /// </summary>
    [Parameter]
    public AzureMapsControl.Components.Traffic.TrafficOptions TrafficOptions { get; set; }

    /// <summary>
    /// Options to display a drawing toolbar on the map
    /// </summary>
    [Parameter]
    public AzureMapsControl.Components.Drawing.DrawingToolbarOptions DrawingToolbarOptions { get; set; }

    /// <summary>
    /// Fired when a "box zoom" interaction ends.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnBoxZoomEnd { get; set; }

    /// <summary>
    /// Fired when a "box zoom" interaction starts.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnBoxZoomStart { get; set; }

    /// <summary>
    /// Fired when a pointing device is pressed and released at the same point on the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnClick { get; set; }

    /// <summary>
    /// Fired when the right button of the mouse is clicked.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnContextMenu { get; set; }

    /// <summary>
    /// Fired when any map data loads or changes.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnData { get; set; }

    /// <summary>
    /// Fired when a pointing device is clicked twice at the same point on the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnDblClick { get; set; }

    /// <summary>
    /// Fired repeatedly during a "drag to pan" interaction on the map, popup, or HTML marker.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnDrag { get; set; }

    /// <summary>
    /// Fired when a "drag to pan" interaction ends on the map, popup, or HTML marker.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnDragEnd { get; set; }

    /// <summary>
    /// Fired when a "drag to pan" interaction starts on the map, popup, or HTML marker.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnDragStart { get; set; }

    /// <summary>
    /// Fired when an error occurs.
    /// </summary>
    [Parameter]
    public EventCallback<MapErrorEventArgs> OnError { get; set; }

    /// <summary>
    /// Fired after the last frame rendered before the map enters an "idle" state:
    /// No camera transitions are in progress.
    /// All currently requested tiles have loaded.
    /// All fade/transition animations have completed.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnIdle { get; set; }

    /// <summary>
    /// Fired after a layer has been added to the map
    /// </summary>
    [Parameter]
    public EventCallback<MapLayerEventArgs> OnLayerAdded { get; set; }

    /// <summary>
    /// Fired after a layer has been removed from the map
    /// </summary>
    [Parameter]
    public EventCallback<MapLayerEventArgs> OnLayerRemoved { get; set; }

    /// <summary>
    /// Fired immediately after all necessary resources have been downloaded and the first visually complete rendering of the map has occurred.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnLoad { get; set; }

    /// <summary>
    /// Fired when a pointing device is pressed within the map or when on top of an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseDown { get; set; }

    /// <summary>
    /// Fired when a pointing device is moved within the map or an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseMove { get; set; }

    /// <summary>
    /// Fired when a point device leaves the map's canvas our leaves an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseOut { get; set; }

    /// <summary>
    /// Fired when a pointing device is moved over the map or an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseOver { get; set; }

    /// <summary>
    /// Fired when a pointing device is released within the map or when on top of an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseUp { get; set; }

    /// <summary>
    /// Fired repeatedly during an animated transition from one view to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnMove { get; set; }

    /// <summary>
    /// Fired just after the map completes a transition from one view to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnMoveEnd { get; set; }

    /// <summary>
    /// Fired just before the map begins a transition from one view to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnMoveStart { get; set; }

    /// <summary>
    /// Fired whenever the map's pitch (tilt) changes as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnPitch { get; set; }

    /// <summary>
    /// Fired immediately after the map's pitch (tilt) finishes changing as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnPitchEnd { get; set; }

    /// <summary>
    /// Fired whenever the map's pitch (tilt) begins a change as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnPitchStart { get; set; }

    /// <summary>
    /// Fired when the minimum required map resources are loaded before the map is ready to be programmatically interacted with.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnReady { get; set; }

    /// <summary>
    /// Fired whenever the map is drawn to the screen, as the result of:
    /// A change to the map's position, zoom, pitch, or bearing.
    /// A change to the map's style.
    /// A change to a DataSource source.
    /// The loading of a vector tile, GeoJSON file, glyph, or sprite.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnRender { get; set; }

    /// <summary>
    /// Fired immediately after the map has been resized.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnResize { get; set; }

    /// <summary>
    /// Fired repeatedly during a "drag to rotate" interaction.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnRotate { get; set; }

    /// <summary>
    /// Fired when a "drag to rotate" interaction ends.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnRotateEnd { get; set; }

    /// <summary>
    /// Fired when a "drag to rotate" interaction starts.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnRotateStart { get; set; }

    /// <summary>
    /// Fired when a DataSource or VectorTileSource is added to the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnSourceAdded { get; set; }

    /// <summary>
    /// Fired when one of the map's sources loads or changes, including if a tile belonging to a source loads or changes.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnSourceData { get; set; }

    /// <summary>
    /// Fired when a DataSource or VectorTileSource is removed from the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnSourceRemoved { get; set; }

    /// <summary>
    /// Fired when the map's style loads or changes.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnStyleData { get; set; }

    /// <summary>
    /// Fired when a layer tries to load an image from the image sprite that doesn't exist
    /// </summary>
    [Parameter]
    public EventCallback<MapMessageEventArgs> OnStyleImageMissing { get; set; }

    /// <summary>
    /// Fired when an AAD access token is obtained.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnTokenAcquired { get; set; }

    /// <summary>
    /// Fired when a touchcancel event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapTouchEventArgs> OnTouchCancel { get; set; }

    /// <summary>
    /// Fired when a touchend event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapTouchEventArgs> OnTouchEnd { get; set; }

    /// <summary>
    /// Fired when a touchmove event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapTouchEventArgs> OnTouchMove { get; set; }

    /// <summary>
    /// Fired when a touchstart event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapTouchEventArgs> OnTouchStart { get; set; }

    /// <summary>
    /// Fired when a mouse wheel event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnWheel { get; set; }

    /// <summary>
    /// Fired repeatedly during an animated transition from one zoom level to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnZoom { get; set; }

    /// <summary>
    /// Fired just after the map completes a transition from one zoom level to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnZoomEnd { get; set; }

    /// <summary>
    /// Fired just before the map begins a transition from one zoom level to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnZoomStart { get; set; }

    /// <summary>
    /// Fired when the drawing mode has changed on the drawing toolbar
    /// </summary>
    [Parameter]
    public EventCallback<AzureMapsControl.Components.Drawing.DrawingToolbarModeEventArgs> OnDrawingModeChanged { get; set; }

    /// <summary>
    /// Fired when a drawing has started
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnDrawingStarted { get; set; }

    /// <summary>
    /// Fired repeatedly when a drawing is changing
    /// </summary>
    [Parameter]
    public EventCallback<AzureMapsControl.Components.Drawing.DrawingToolbarEventArgs> OnDrawingChanging { get; set; }

    /// <summary>
    /// Fired when a drawing has changed
    /// </summary>
    [Parameter]
    public EventCallback<AzureMapsControl.Components.Drawing.DrawingToolbarEventArgs> OnDrawingChanged { get; set; }

    /// <summary>
    /// Fires when a drawing is completed
    /// </summary>
    [Parameter]
    public EventCallback<AzureMapsControl.Components.Drawing.DrawingToolbarEventArgs> OnDrawingComplete { get; set; }

    #endregion

    #region Razor events

    protected override void OnInitialized()
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_OnInitialized, "AzureMap - OnInitialized");
        _mapEventInvokeHelper = new MapEventInvokeHelper(MapEventReceivedAsync);
        _htmlMarkerEventInvokeHelper = new Markers.HtmlMarkerInvokeHelper(HtmlMarkerEventReceivedAsync);
        _drawingToolbarEventInvokeHelper = new Drawing.DrawingToolbarEventInvokeHelper(DrawingToolbarEventReceivedAsync);
        _layerEventInvokeHelper = new Layers.LayerEventInvokeHelper(LayerEventReceivedAsync);
        _popupInvokeHelper = new Popups.PopupInvokeHelper(PopupEventReceivedAsync);
        base.OnInitialized();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_OnInitialized, "AzureMap - OnAfterRenderAsync", firstRender);
        if (firstRender)
        {
            var enabledEvents = (EventActivationFlags ?? MapEventActivationFlags.None().Enable(MapEventType.Ready)).EnabledEvents;
            Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_OnInitialized, $"Adding map");
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_OnInitialized, $"Id: {Id}");
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_OnInitialized, $"AuthType: {Configuration.Value.AuthType}");
            Logger?.LogAzureMapsControlTrace(AzureMapLogEvent.AzureMap_OnInitialized, $"AadAppId: {Configuration.Value.AadAppId} | AadTenant: {Configuration.Value.AadTenant} | ClientId: {Configuration.Value.ClientId} | SubscriptionKey: {Configuration.Value.SubscriptionKey}");
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_OnInitialized, $"Events: {string.Join('|', enabledEvents)}");
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddMap.ToAzureMapsControlNamespace(),
                Id,
                Configuration.Value,
                ServiceOptions,
                enabledEvents,
                DotNetObjectReference.Create(_mapEventInvokeHelper));
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    #endregion

    #region Controls

    private async Task AddControlsAsync(IEnumerable<Control> controls)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_AddControlsAsync, "AzureMap - AddControlsAsync");
        var newControls = controls?.Where(control => control != null);
        if (newControls != null && newControls.Any())
        {
            var controlOptions = newControls.Select(control => new ControlOptions
            {
                Type = control.Type.ToString(),
                Position = control.Position.ToString()
            });
            Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_AddControlsAsync, $"Adding controls", controlOptions);
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_AddControlsAsync, $"{controlOptions.Count()} controls will be added: {string.Join('|', controlOptions.Select(co => co.Type))}");
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddControl.ToAzureMapsControlNamespace(), controlOptions);
        }
    }

    #endregion

    #region Data sources

    private async Task ClearSourcesAsync()
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_ClearSourcesAsync, $"Clearing sources");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearSources.ToAzureMapsControlNamespace());
    }

    private async Task AddSourceAsync(AzureMapsControl.Components.Data.Source source)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_AddSourceAsync, "Adding source");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_AddSourceAsync, $"Id: {source.Id} | Type: {source.SourceType.ToString()}");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddSource.ToAzureMapsControlNamespace(), source.Id, source.GetSourceOptions()?.GenerateJsOptions(), source.SourceType.ToString());
    }

    private void AttachDataSourcesCallback(AzureMapsControl.Components.Data.DataSource dataSource)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_AttachDataSourcesCallback, "Attaching callbacks to data source");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_AttachDataSourcesCallback, $"Id: {dataSource.Id} | Type: {dataSource.SourceType.ToString()}");
        dataSource.ImportDataFromUrlCallback = DataSource_ImportDataFromUrlAsync;
        dataSource.AddCallback = DataSource_AddAsync;
        dataSource.RemoveCallback = DataSource_RemoveAsync;
        dataSource.ClearCallback = DataSource_ClearAsync;
    }

    private async Task RemoveSourceAsync(string dataSourceId)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_RemoveSourceAsync, "Removing data source");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_RemoveSourceAsync, $"Id: {dataSourceId}");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodRemoveSource.ToAzureMapsControlNamespace(), dataSourceId);
    }

    private async Task DataSource_ImportDataFromUrlAsync(string id, string url)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_DataSource_ImportDataFromUrlAsync, "Importing data from url into data source");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_DataSource_ImportDataFromUrlAsync, $"Id: {id} | Url: {url}");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceImportDataFromUrl.ToAzureMapsControlNamespace(), id, url);
    }

    private async Task DataSource_AddAsync(string id, IEnumerable<Geometry> geometries)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_DataSource_AddAsync, "Adding geometries to data source");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_DataSource_AddAsync, $"Id: {id}");
        var lineStrings = geometries.OfType<LineString>();
        if (lineStrings.Any())
        {
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_DataSource_AddAsync, $"{lineStrings.Count()} linestrings will be added");
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, lineStrings);
        }

        var multiLineStrings = geometries.OfType<MultiLineString>();
        if (multiLineStrings.Any())
        {
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_DataSource_AddAsync, $"{multiLineStrings.Count()} multilinestrings will be added");
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, multiLineStrings);
        }

        var multiPoints = geometries.OfType<MultiPoint>();
        if (multiPoints.Any())
        {
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_DataSource_AddAsync, $"{multiPoints.Count()} multipoints will be added");
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, multiPoints);
        }

        var multiPolygons = geometries.OfType<MultiPolygon>();
        if (multiPolygons.Any())
        {
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_DataSource_AddAsync, $"{multiPolygons.Count()} multipolygons will be added");
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, multiPolygons);
        }

        var points = geometries.OfType<Point>();
        if (points.Any())
        {
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_DataSource_AddAsync, $"{points.Count()} points will be added");
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, points);
        }

        var polygons = geometries.OfType<Polygon>();
        if (polygons.Any())
        {
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_DataSource_AddAsync, $"{polygons.Count()} polygons will be added");
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, polygons);
        }
    }

    private async Task DataSource_RemoveAsync(string id, IEnumerable<string> geometryIds)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_DataSource_RemoveAsync, "Removing geometries from data source");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_DataSource_RemoveAsync, $"Id: {id} | GeometryIds: {string.Join('|', geometryIds)}");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceRemove.ToAzureMapsControlNamespace(), id, geometryIds);
    }

    private async Task DataSource_ClearAsync(string dataSourceId)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_DataSource_ClearAsync, "Clearing data source");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_DataSource_ClearAsync, $"Id: {dataSourceId}");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceClear.ToAzureMapsControlNamespace(), dataSourceId);
    }

    #endregion

    #region Drawing Toolbar

    private async Task DrawingToolbarEventReceivedAsync(AzureMapsControl.Components.Drawing.DrawingToolbarJsEventArgs drawingToolbarEvent)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_DrawingToolbarEvent, "Received drawing toolbar event");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_DrawingToolbarEvent, $"Type: {drawingToolbarEvent.Type}");
        MapService.Map.DispatchDrawingToolbarEvent(drawingToolbarEvent);
        switch (drawingToolbarEvent.Type)
        {
            case "drawingchanged":
                Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_DrawingToolbarEvent, "Emitting OnDrawingChanged");
                await OnDrawingChanged.InvokeAsync(new Drawing.DrawingToolbarEventArgs(MapService.Map, drawingToolbarEvent));
                break;

            case "drawingchanging":
                Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_DrawingToolbarEvent, "Emitting OnDrawingChanging");
                await OnDrawingChanging.InvokeAsync(new Drawing.DrawingToolbarEventArgs(MapService.Map, drawingToolbarEvent));
                break;

            case "drawingcomplete":
                Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_DrawingToolbarEvent, "Emitting OnDrawingComplete");
                await OnDrawingComplete.InvokeAsync(new Drawing.DrawingToolbarEventArgs(MapService.Map, drawingToolbarEvent));
                break;

            case "drawingmodechanged":
                Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_DrawingToolbarEvent, "Emitting OnDrawingModeChanged");
                await OnDrawingModeChanged.InvokeAsync(new Drawing.DrawingToolbarModeEventArgs(MapService.Map, drawingToolbarEvent));
                break;

            case "drawingstarted":
                Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_DrawingToolbarEvent, "Emitting OnDrawingStarted");
                await OnDrawingStarted.InvokeAsync(new MapEventArgs(MapService.Map, drawingToolbarEvent.Type));
                break;
        }
    }

    private async Task AddDrawingToolbarAsync(AzureMapsControl.Components.Drawing.DrawingToolbarOptions drawingToolbarOptions)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_AddDrawingToolbarAsync, "Adding drawing toolbar");
        if (drawingToolbarOptions != null)
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddDrawingToolbar.ToAzureMapsControlNamespace(),
            new AzureMapsControl.Components.Drawing.DrawingToolbarCreationOptions
            {
                Buttons = drawingToolbarOptions.Buttons?.Select(button => button.ToString()).ToArray(),
                ContainerId = drawingToolbarOptions.ContainerId,
                DragHandleStyle = drawingToolbarOptions.DragHandleStyle,
                FreehandInterval = drawingToolbarOptions.FreehandInterval,
                InteractionType = drawingToolbarOptions.InteractionType.ToString(),
                Mode = drawingToolbarOptions.Mode.ToString(),
                NumColumns = drawingToolbarOptions.NumColumns,
                Position = drawingToolbarOptions.Position.ToString(),
                SecondaryDragHandleStyle = drawingToolbarOptions.SecondaryDragHandleStyle,
                ShapeDraggingEnabled = drawingToolbarOptions.ShapesDraggingEnabled,
                Style = drawingToolbarOptions.Style.ToString(),
                Visible = drawingToolbarOptions.Visible,
                Events = drawingToolbarOptions.Events?.EnabledEvents
            },
            DotNetObjectReference.Create(_drawingToolbarEventInvokeHelper));
        }
    }

    private async Task UpdateDrawingToolbarAsync(AzureMapsControl.Components.Drawing.DrawingToolbarUpdateOptions drawingToolbarOptions)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_UpdateDrawingToolbarAsync, "Updating drawing toolbar");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodUpdateDrawingToolbar.ToAzureMapsControlNamespace(),
            new AzureMapsControl.Components.Drawing.DrawingToolbarCreationOptions
            {
                Buttons = drawingToolbarOptions.Buttons?.Select(button => button.ToString()).ToArray(),
                ContainerId = drawingToolbarOptions.ContainerId,
                NumColumns = drawingToolbarOptions.NumColumns,
                Position = drawingToolbarOptions.Position.ToString(),
                Style = drawingToolbarOptions.Style.ToString(),
                Visible = drawingToolbarOptions.Visible
            });
    }

    private async Task RemoveDrawingToolbarAsync()
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_RemoveDrawingToolbarAsync, "Removing drawing toolbar");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodRemoveDrawingToolbar.ToAzureMapsControlNamespace());
    }

    #endregion

    #region HTML Markers

    private async Task HtmlMarkerEventReceivedAsync(AzureMapsControl.Components.Markers.HtmlMarkerJsEventArgs htmlMarkerEvent)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_HtmlMarkerEventReceivedAsync, "Received html marker event");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_HtmlMarkerEventReceivedAsync, $"Id: {htmlMarkerEvent.MarkerId} | Type: {htmlMarkerEvent.Type}");
        if (MapService.Map.HtmlMarkers != null)
        {
            var htmlMarker = MapService.Map.HtmlMarkers.First(marker => marker.Id == htmlMarkerEvent.MarkerId);
            if (htmlMarker != null)
            {
                await Task.Run(() =>
                {
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_HtmlMarkerEventReceivedAsync, "Dispatching html marker event");
                    Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_HtmlMarkerEventReceivedAsync, $"Id: {htmlMarkerEvent.MarkerId} | Type: {htmlMarkerEvent.Type}");
                    htmlMarker.DispatchEvent(MapService.Map, htmlMarkerEvent);
                });
            }
        }
    }

    private async Task ClearHtmlMarkersAsync()
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_ClearHtmlMarkersAsync, "Clearing html markers");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearHtmlMarkers.ToAzureMapsControlNamespace());
    }

    private async Task AddHtmlMarkersAsync(IEnumerable<AzureMapsControl.Components.Markers.HtmlMarker> htmlMarkers)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_AddHtmlMarkersAsync, "Adding html markers");
        var newHtmlMarkers = htmlMarkers?.Where(marker => marker != null);
        if (newHtmlMarkers != null && newHtmlMarkers.Any())
        {
            Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_AddHtmlMarkersAsync, $"{newHtmlMarkers.Count()} new html markers will be added");
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddHtmlMarkers.ToAzureMapsControlNamespace(),
            newHtmlMarkers.Select(marker => new AzureMapsControl.Components.Markers.HtmlMarkerCreationOptions
            {
                Id = marker.Id,
                Events = marker.EventActivationFlags?.EnabledEvents,
                Options = marker.Options
            }),
            DotNetObjectReference.Create(_htmlMarkerEventInvokeHelper));
        }
    }

    private async Task RemoveHtmlMarkersAsync(IEnumerable<AzureMapsControl.Components.Markers.HtmlMarker> htmlMarkers)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_RemoveHtmlMarkersAsync, "Removing html markers");
        var htmlMarkersToRemove = htmlMarkers?.Where(marker => marker != null && Guid.TryParse(marker.Id, out _));
        if (htmlMarkersToRemove.Any())
        {
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_RemoveHtmlMarkersAsync, $"{htmlMarkersToRemove.Count()} html markers will be removed");
            var ids = htmlMarkersToRemove.Select(marker => marker.Id);
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_RemoveHtmlMarkersAsync, $"Ids: {string.Join('|', ids)}");
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodRemoveHtmlMarkers.ToAzureMapsControlNamespace(), ids);
        }
    }

    private async Task UpdateHtmlMarkersAsync(IEnumerable<AzureMapsControl.Components.Markers.HtmlMarkerUpdate> updates)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_UpdateHtmlMarkersAsync, "Updating html markers");
        var htmlMarkersToUpdate = updates?.Where(htmlMarker => htmlMarker?.Marker != null && htmlMarker.Options != null);
        if (htmlMarkersToUpdate != null && htmlMarkersToUpdate.Any())
        {
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_UpdateHtmlMarkersAsync, $"{htmlMarkersToUpdate.Count()} html markers will be updated");
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_UpdateHtmlMarkersAsync, $"Ids: {string.Join('|', htmlMarkersToUpdate.Select(h => h.Marker.Id))}");
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodUpdateHtmlMarkers.ToAzureMapsControlNamespace(),
            htmlMarkersToUpdate.Select(update => new AzureMapsControl.Components.Markers.HtmlMarkerCreationOptions
            {
                Id = update.Marker.Id,
                Options = update.Options
            }));
        }
    }

    #endregion

    #region Layers

    private async Task LayerEventReceivedAsync(MapJsEventArgs eventArgs)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_LayerEventReceivedAsync, "Layer event received");
        var layer = MapService.Map.Layers.FirstOrDefault(l => l.Id == eventArgs.LayerId);
        if (layer != null)
        {
            await Task.Run(() =>
            {
                Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_LayerEventReceivedAsync, "Dispatching layer event");
                Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_LayerEventReceivedAsync, $"Id: {layer.Id} | Type: {eventArgs.Type}");
                layer.DispatchEvent(MapService.Map, eventArgs);
            });
        }
    }

    private async Task ClearLayersAsync()
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_ClearLayersAsync, "Clearing layers");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearLayers.ToAzureMapsControlNamespace());
    }

    private async Task AddLayerAsync(AzureMapsControl.Components.Layers.Layer layer, string before)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_AddLayerAsync, "Adding layer");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_AddLayerAsync, $"Id: {layer.Id} | Type: {layer.Type} | Events: {string.Join('|', layer.EventActivationFlags.EnabledEvents)} | Before: {before}");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddLayer.ToAzureMapsControlNamespace(),
            layer.Id,
            before,
            layer.Type.ToString(),
            layer.GetLayerOptions()?.GenerateJsOptions(),
            layer.EventActivationFlags.EnabledEvents,
            DotNetObjectReference.Create(_layerEventInvokeHelper));
    }

    private async Task RemoveLayersAsync(IEnumerable<string> layerIds)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_RemoveLayersAsync, "Removing layers");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_RemoveLayersAsync, $"Ids: {string.Join('|', layerIds)}");

        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodRemoveLayers.ToAzureMapsControlNamespace(), layerIds);
    }

    #endregion

    #region Map

    private async Task MapEventReceivedAsync(MapJsEventArgs mapEvent)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Received map event");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, $"Type: {mapEvent.Type}");
        if (mapEvent.Type == "ready")
        {
            Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Setting map options");
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodSetOptions.ToAzureMapsControlNamespace(),
                CameraOptions,
                StyleOptions,
                UserInteractionOptions,
                TrafficOptions);

            await MapService.AddMapAsync(new Map(Id,
                AddControlsAsync,
                AddHtmlMarkersAsync,
                UpdateHtmlMarkersAsync,
                RemoveHtmlMarkersAsync,
                AddDrawingToolbarAsync,
                UpdateDrawingToolbarAsync,
                RemoveDrawingToolbarAsync,
                AddLayerAsync,
                RemoveLayersAsync,
                AddSourceAsync,
                RemoveSourceAsync,
                AttachDataSourcesCallback,
                ClearMapAsync,
                ClearLayersAsync,
                ClearSourcesAsync,
                ClearHtmlMarkersAsync,
                AddPopupAsync,
                Popup_RemoveAsync,
                ClearPopupsAsync,
                SetCameraOptionsAsync,
                SetStyleOptionsAsync,
                SetUserInteractionAsync,
                SetTrafficAsync)
            {
                Controls = Controls,
                HtmlMarkers = HtmlMarkers,
                DrawingToolbarOptions = DrawingToolbarOptions,
                CameraOptions = CameraOptions,
                StyleOptions = StyleOptions,
                UserInteractionOptions = UserInteractionOptions,
                TrafficOptions = TrafficOptions
            });

            await AddControlsAsync(Controls);
            await AddHtmlMarkersAsync(HtmlMarkers);
            await AddDrawingToolbarAsync(DrawingToolbarOptions);
        }
        await DispatchMapEventAsync(mapEvent);
    }

    private async Task SetCameraOptionsAsync(CameraOptions options)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_SetCameraOptionsAsync, "Setting camera options");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodSetCameraOptions.ToAzureMapsControlNamespace(), options);
    }

    private async Task SetStyleOptionsAsync(StyleOptions options)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_SetStyleOptionsAsync, "Setting style options");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodSetStyleOptions.ToAzureMapsControlNamespace(), options);
    }

    private async Task SetUserInteractionAsync(UserInteractionOptions options)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_SetUserInteractionAsync, "Setting user interaction options");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodSetUserInteraction.ToAzureMapsControlNamespace(), options);
    }

    private async Task SetTrafficAsync(AzureMapsControl.Components.Traffic.TrafficOptions options)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_SetTrafficAsync, "Setting traffic options");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodSetTraffic.ToAzureMapsControlNamespace(), options);
    }

    private async Task ClearMapAsync()
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_ClearMapAsync, "Clearing map");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearMap.ToAzureMapsControlNamespace());
    }

    private async Task DispatchMapEventAsync(MapJsEventArgs mapEvent)
    {
        if (EventActivationFlags != null
        && EventActivationFlags.EnabledEvents != null
        && EventActivationFlags.EnabledEvents.Contains(mapEvent.Type))
        {
            MapService.Map.DispatchEvent(mapEvent);
            switch (mapEvent.Type)
            {
                case "boxzoomend":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnBoxZoomEnd");
                    await OnBoxZoomEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "boxzoomstart":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnBoxZoomStart");
                    await OnBoxZoomStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "click":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnClick");
                    await OnClick.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "contextmenu":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnContextMenu");
                    await OnContextMenu.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "data":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnData");
                    await OnData.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "dblclick":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnDblClick");
                    await OnDblClick.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "drag":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnDrag");
                    await OnDrag.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "dragend":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnDragEnd");
                    await OnDragEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "dragstart":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnDragStart");
                    await OnDragStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "error":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnError");
                    await OnError.InvokeAsync(new MapErrorEventArgs(MapService.Map, mapEvent));
                    break;
                case "idle":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnIdle");
                    await OnIdle.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "layeradded":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnLayerAdded");
                    await OnLayerAdded.InvokeAsync(new MapLayerEventArgs(MapService.Map, mapEvent));
                    break;
                case "layerremoved":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnLayerRemoved");
                    await OnLayerRemoved.InvokeAsync(new MapLayerEventArgs(MapService.Map, mapEvent));
                    break;
                case "load":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnLoad");
                    await OnLoad.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "mousedown":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnMouseDown");
                    await OnMouseDown.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "mousemove":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnMouseMove");
                    await OnMouseMove.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "mouseout":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnMouseOut");
                    await OnMouseOut.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "mouseover":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnMouseOver");
                    await OnMouseOver.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "mouseup":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnMouseUp");
                    await OnMouseUp.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "move":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnMove");
                    await OnMove.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "moveend":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnMoveEnd");
                    await OnMoveEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "movestart":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnMoveStart");
                    await OnMoveStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "pitch":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnPitch");
                    await OnPitch.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "pitchend":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnPitchEnd");
                    await OnPitchEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "pitchstart":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnPitchStart");
                    await OnPitchStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "ready":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnReady");
                    await OnReady.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "render":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnRender");
                    await OnRender.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "resize":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnResize");
                    await OnResize.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "rotate":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnRotate");
                    await OnRotate.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "rotateend":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnRotateEnd");
                    await OnRotateEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "rotatestart":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnRotateStart");
                    await OnRotateStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "sourceadded":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnSourceAdded");
                    await OnSourceAdded.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "sourcedata":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnSourceData");
                    await OnSourceData.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "sourceremoved":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnSourceRemoved");
                    await OnSourceRemoved.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "styledata":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnStyleData");
                    await OnStyleData.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "styleimagemissing":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnStyleImageMissing");
                    await OnStyleImageMissing.InvokeAsync(new MapMessageEventArgs(MapService.Map, mapEvent));
                    break;
                case "tokenacquired":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnTokenAcquired");
                    await OnTokenAcquired.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "touchcancel":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnTouchCancel");
                    await OnTouchCancel.InvokeAsync(new MapTouchEventArgs(MapService.Map, mapEvent));
                    break;
                case "touchend":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnTouchEnd");
                    await OnTouchEnd.InvokeAsync(new MapTouchEventArgs(MapService.Map, mapEvent));
                    break;
                case "touchmove":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnTouchMove");
                    await OnTouchMove.InvokeAsync(new MapTouchEventArgs(MapService.Map, mapEvent));
                    break;
                case "touchstart":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnTouchStart");
                    await OnTouchStart.InvokeAsync(new MapTouchEventArgs(MapService.Map, mapEvent));
                    break;
                case "wheel":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnWheel");
                    await OnWheel.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "zoom":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnZoom");
                    await OnZoom.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "zoomend":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnZoomEnd");
                    await OnZoomEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "zoomstart":
                    Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_MapEventReceivedAsync, "Emitting OnZoomStart");
                    await OnZoomStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
            }
        }
    }

    #endregion

    #region Popups

    private async Task AddPopupAsync(AzureMapsControl.Components.Popups.Popup popup)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_AddPopupAsync, "Adding popup");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_AddPopupAsync, $"Id: {popup.Id} | Events: {string.Join('|', popup.EventActivationFlags.EnabledEvents)}");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddPopup.ToAzureMapsControlNamespace(), popup.Id, popup.Options, popup.EventActivationFlags.EnabledEvents, DotNetObjectReference.Create(_popupInvokeHelper));
        popup.OpenPopupCallback = Popup_OpenAsync;
        popup.ClosePopupCallback = Popup_CloseAsync;
        popup.RemoveCallback = Popup_RemoveAsync;
        popup.UpdateCallback = Popup_UpdateAsync;
    }

    private async Task Popup_OpenAsync(string id)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_Popup_OpenAsync, "Opening popup");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_Popup_OpenAsync, $"Id: {id}");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodPopupOpen.ToAzureMapsControlNamespace(), id);
    }

    private async Task Popup_CloseAsync(string id)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_Popup_CloseAsync, "Closing popup");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_Popup_CloseAsync, $"Id: {id}");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodPopupClose.ToAzureMapsControlNamespace(), id);
    }

    private async Task Popup_RemoveAsync(string id)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_Popup_RemoveAsync, "Removing popup");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_Popup_RemoveAsync, $"Id: {id}");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodPopupRemove.ToAzureMapsControlNamespace(), id);
        MapService.Map.RemovePopup(id);
    }

    private async Task Popup_UpdateAsync(string id, AzureMapsControl.Components.Popups.PopupOptions options)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_Popup_UpdateAsync, "Removing popup");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_Popup_UpdateAsync, $"Id: {id}");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodPopupUpdate.ToAzureMapsControlNamespace(), id, options);
    }

    private async Task ClearPopupsAsync()
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_ClearPopupsAsync, "Clearing popups");
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearPopups.ToAzureMapsControlNamespace());
    }

    private async Task PopupEventReceivedAsync(AzureMapsControl.Components.Popups.PopupEventArgs eventArgs)
    {
        Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_PopupEventReceivedAsync, "Received popup event");
        Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_PopupEventReceivedAsync, $"Id: {eventArgs.Id} | Type: {eventArgs.Type}");
        await Task.Run(
        () =>
        {
            Logger?.LogAzureMapsControlInfo(AzureMapLogEvent.AzureMap_PopupEventReceivedAsync, "Dispatching popup event");
            Logger?.LogAzureMapsControlDebug(AzureMapLogEvent.AzureMap_PopupEventReceivedAsync, $"Id: {eventArgs.Id} | Type: {eventArgs.Type}");
            MapService.Map.Popups.First(popup => popup.Id == eventArgs.Id).DispatchEvent(eventArgs);
        });
    }

    #endregion
}
