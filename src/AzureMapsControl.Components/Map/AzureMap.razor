@namespace AzureMapsControl.Components.Map

@using AzureMapsControl.Components.Atlas
@using AzureMapsControl.Components.Configuration

@using Microsoft.JSInterop
@using Microsoft.Extensions.Options

@inject IOptions<AzureMapsConfiguration> Configuration
@inject IMapAdderService MapService
@inject IJSRuntime JSRuntime

<div id="@Id"></div>

@code {

    #region Fields

    private MapEventInvokeHelper _mapEventInvokeHelper;
    private Markers.HtmlMarkerInvokeHelper _htmlMarkerEventInvokeHelper;
    private Drawing.DrawingToolbarEventInvokeHelper _drawingToolbarEventInvokeHelper;
    private Layers.LayerEventInvokeHelper _layerEventInvokeHelper;
    private Popups.PopupInvokeHelper _popupInvokeHelper;

    private string _id;

    #endregion

    #region Parameters

    /// <summary>
    /// The options for setting the map control's camera.
    /// </summary>
    [Parameter]
    public CameraOptions CameraOptions { get; set; } = new CameraOptions();

    /// <summary>
    /// Options for the map's style.
    /// </summary>
    [Parameter]
    public StyleOptions StyleOptions { get; set; } = new StyleOptions();

    /// <summary>
    /// Options for enabling/disabling user interaction with the map.
    /// </summary>
    [Parameter]
    public UserInteractionOptions UserInteractionOptions { get; set; } = new UserInteractionOptions();

    /// <summary>
    /// Global properties used in all atlas service requests.
    /// </summary>
    [Parameter]
    public ServiceOptions ServiceOptions { get; set; } = new ServiceOptions();

    /// <summary>
    /// Id affected to the div hosting the map
    /// </summary>
    [Parameter]
    public string Id
    {
        get => _id;
        set { if (string.IsNullOrWhiteSpace(value)) { throw new ArgumentException("ID on the map is mandatory"); } _id = value; }
    }

    /// <summary>
    /// Defines the events which needs to be activated
    /// </summary>
    [Parameter]
    public MapEventActivationFlags EventActivationFlags { get; set; }

    /// <summary>
    /// Defines the controls to add to the map when it is ready
    /// </summary>
    [Parameter]
    public IReadOnlyCollection<Control> Controls { get; set; }

    /// <summary>
    /// HtmlMarkers to add to the map when it is ready
    /// </summary>
    [Parameter]
    public IReadOnlyCollection<AzureMapsControl.Components.Markers.HtmlMarker> HtmlMarkers { get; set; }

    /// <summary>
    /// Options to display traffic on the map
    /// </summary>
    [Parameter]
    public AzureMapsControl.Components.Traffic.TrafficOptions TrafficOptions { get; set; }

    /// <summary>
    /// Options to display a drawing toolbar on the map
    /// </summary>
    [Parameter]
    public AzureMapsControl.Components.Drawing.DrawingToolbarOptions DrawingToolbarOptions { get; set; }

    /// <summary>
    /// Fired when a "box zoom" interaction ends.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnBoxZoomEnd { get; set; }

    /// <summary>
    /// Fired when a "box zoom" interaction starts.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnBoxZoomStart { get; set; }

    /// <summary>
    /// Fired when a pointing device is pressed and released at the same point on the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnClick { get; set; }

    /// <summary>
    /// Fired when the right button of the mouse is clicked.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnContextMenu { get; set; }

    /// <summary>
    /// Fired when any map data loads or changes.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnData { get; set; }

    /// <summary>
    /// Fired when a pointing device is clicked twice at the same point on the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnDblClick { get; set; }

    /// <summary>
    /// Fired repeatedly during a "drag to pan" interaction on the map, popup, or HTML marker.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnDrag { get; set; }

    /// <summary>
    /// Fired when a "drag to pan" interaction ends on the map, popup, or HTML marker.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnDragEnd { get; set; }

    /// <summary>
    /// Fired when a "drag to pan" interaction starts on the map, popup, or HTML marker.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnDragStart { get; set; }

    /// <summary>
    /// Fired when an error occurs.
    /// </summary>
    [Parameter]
    public EventCallback<MapErrorEventArgs> OnError { get; set; }

    /// <summary>
    /// Fired after the last frame rendered before the map enters an "idle" state:
    /// No camera transitions are in progress.
    /// All currently requested tiles have loaded.
    /// All fade/transition animations have completed.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnIdle { get; set; }

    /// <summary>
    /// Fired after a layer has been added to the map
    /// </summary>
    [Parameter]
    public EventCallback<MapLayerEventArgs> OnLayerAdded { get; set; }

    /// <summary>
    /// Fired after a layer has been removed from the map
    /// </summary>
    [Parameter]
    public EventCallback<MapLayerEventArgs> OnLayerRemoved { get; set; }

    /// <summary>
    /// Fired immediately after all necessary resources have been downloaded and the first visually complete rendering of the map has occurred.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnLoad { get; set; }

    /// <summary>
    /// Fired when a pointing device is pressed within the map or when on top of an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseDown { get; set; }

    /// <summary>
    /// Fired when a pointing device is moved within the map or an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseMove { get; set; }

    /// <summary>
    /// Fired when a point device leaves the map's canvas our leaves an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseOut { get; set; }

    /// <summary>
    /// Fired when a pointing device is moved over the map or an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseOver { get; set; }

    /// <summary>
    /// Fired when a pointing device is released within the map or when on top of an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseUp { get; set; }

    /// <summary>
    /// Fired repeatedly during an animated transition from one view to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnMove { get; set; }

    /// <summary>
    /// Fired just after the map completes a transition from one view to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnMoveEnd { get; set; }

    /// <summary>
    /// Fired just before the map begins a transition from one view to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnMoveStart { get; set; }

    /// <summary>
    /// Fired whenever the map's pitch (tilt) changes as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnPitch { get; set; }

    /// <summary>
    /// Fired immediately after the map's pitch (tilt) finishes changing as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnPitchEnd { get; set; }

    /// <summary>
    /// Fired whenever the map's pitch (tilt) begins a change as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnPitchStart { get; set; }

    /// <summary>
    /// Fired when the minimum required map resources are loaded before the map is ready to be programmatically interacted with.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnReady { get; set; }

    /// <summary>
    /// Fired whenever the map is drawn to the screen, as the result of:
    /// A change to the map's position, zoom, pitch, or bearing.
    /// A change to the map's style.
    /// A change to a DataSource source.
    /// The loading of a vector tile, GeoJSON file, glyph, or sprite.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnRender { get; set; }

    /// <summary>
    /// Fired immediately after the map has been resized.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnResize { get; set; }

    /// <summary>
    /// Fired repeatedly during a "drag to rotate" interaction.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnRotate { get; set; }

    /// <summary>
    /// Fired when a "drag to rotate" interaction ends.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnRotateEnd { get; set; }

    /// <summary>
    /// Fired when a "drag to rotate" interaction starts.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnRotateStart { get; set; }

    /// <summary>
    /// Fired when a DataSource or VectorTileSource is added to the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnSourceAdded { get; set; }

    /// <summary>
    /// Fired when one of the map's sources loads or changes, including if a tile belonging to a source loads or changes.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnSourceData { get; set; }

    /// <summary>
    /// Fired when a DataSource or VectorTileSource is removed from the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnSourceRemoved { get; set; }

    /// <summary>
    /// Fired when the map's style loads or changes.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnStyleData { get; set; }

    /// <summary>
    /// Fired when a layer tries to load an image from the image sprite that doesn't exist
    /// </summary>
    [Parameter]
    public EventCallback<MapMessageEventArgs> OnStyleImageMissing { get; set; }

    /// <summary>
    /// Fired when an AAD access token is obtained.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnTokenAcquired { get; set; }

    /// <summary>
    /// Fired when a touchcancel event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapTouchEventArgs> OnTouchCancel { get; set; }

    /// <summary>
    /// Fired when a touchend event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapTouchEventArgs> OnTouchEnd { get; set; }

    /// <summary>
    /// Fired when a touchmove event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapTouchEventArgs> OnTouchMove { get; set; }

    /// <summary>
    /// Fired when a touchstart event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapTouchEventArgs> OnTouchStart { get; set; }

    /// <summary>
    /// Fired when a mouse wheel event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnWheel { get; set; }

    /// <summary>
    /// Fired repeatedly during an animated transition from one zoom level to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnZoom { get; set; }

    /// <summary>
    /// Fired just after the map completes a transition from one zoom level to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnZoomEnd { get; set; }

    /// <summary>
    /// Fired just before the map begins a transition from one zoom level to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnZoomStart { get; set; }

    /// <summary>
    /// Fired when the drawing mode has changed on the drawing toolbar
    /// </summary>
    [Parameter]
    public EventCallback<AzureMapsControl.Components.Drawing.DrawingToolbarModeEventArgs> OnDrawingModeChanged { get; set; }

    /// <summary>
    /// Fired when a drawing has started
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnDrawingStarted { get; set; }

    /// <summary>
    /// Fired repeatedly when a drawing is changing
    /// </summary>
    [Parameter]
    public EventCallback<AzureMapsControl.Components.Drawing.DrawingToolbarEventArgs> OnDrawingChanging { get; set; }

    /// <summary>
    /// Fired when a drawing has changed
    /// </summary>
    [Parameter]
    public EventCallback<AzureMapsControl.Components.Drawing.DrawingToolbarEventArgs> OnDrawingChanged { get; set; }

    /// <summary>
    /// Fires when a drawing is completed
    /// </summary>
    [Parameter]
    public EventCallback<AzureMapsControl.Components.Drawing.DrawingToolbarEventArgs> OnDrawingComplete { get; set; }

    #endregion

    #region Razor events

    protected override void OnInitialized()
    {
        _mapEventInvokeHelper = new MapEventInvokeHelper(MapEventReceivedAsync);
        _htmlMarkerEventInvokeHelper = new Markers.HtmlMarkerInvokeHelper(HtmlMarkerEventReceivedAsync);
        _drawingToolbarEventInvokeHelper = new Drawing.DrawingToolbarEventInvokeHelper(DrawingToolbarEventReceivedAsync);
        _layerEventInvokeHelper = new Layers.LayerEventInvokeHelper(LayerEventReceivedAsync);
        _popupInvokeHelper = new Popups.PopupInvokeHelper(PopupEventReceivedAsync);
        base.OnInitialized();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddMap.ToAzureMapsControlNamespace(),
                Id,
                Configuration.Value,
                ServiceOptions,
                (EventActivationFlags ?? MapEventActivationFlags.None().Enable(MapEventType.Ready)).EnabledEvents,
                DotNetObjectReference.Create(_mapEventInvokeHelper));
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    #endregion

    #region Controls

    private async Task AddControlsAsync(IEnumerable<Control> controls)
    {
        var newControls = controls?.Where(control => control != null);
        if (newControls != null && newControls.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddControl.ToAzureMapsControlNamespace(),
            newControls.Select(control => new ControlOptions
            {
                Type = control.Type.ToString(),
                Position = control.Position.ToString()
            }));
        }
    }

    #endregion

    #region Data sources

    private async Task ClearSourcesAsync() => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearSources.ToAzureMapsControlNamespace());

    private async Task AddSourceAsync(AzureMapsControl.Components.Data.Source source) =>
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddSource.ToAzureMapsControlNamespace(), source.Id, source.GetSourceOptions()?.GenerateJsOptions(), source.SourceType.ToString());

    private void AttachDataSourcesCallback(AzureMapsControl.Components.Data.DataSource dataSource)
    {
        dataSource.ImportDataFromUrlCallback = DataSource_ImportDataFromUrlAsync;
        dataSource.AddCallback = DataSource_AddAsync;
        dataSource.RemoveCallback = DataSource_RemoveAsync;
        dataSource.ClearCallback = DataSource_ClearAsync;
    }

    private async Task RemoveSourceAsync(string dataSourceId) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodRemoveSource.ToAzureMapsControlNamespace(), dataSourceId);

    private async Task DataSource_ImportDataFromUrlAsync(string id, string url) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceImportDataFromUrl.ToAzureMapsControlNamespace(), id, url);

    private async Task DataSource_AddAsync(string id, IEnumerable<Geometry> geometries)
    {
        var lineStrings = geometries.OfType<LineString>();
        if (lineStrings.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, lineStrings);
        }

        var multiLineStrings = geometries.OfType<MultiLineString>();
        if (multiLineStrings.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, multiLineStrings);
        }

        var multiPoints = geometries.OfType<MultiPoint>();
        if (multiPoints.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, multiPoints);
        }

        var multiPolygons = geometries.OfType<MultiPolygon>();
        if (multiPolygons.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, multiPolygons);
        }

        var points = geometries.OfType<Point>();
        if (points.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, points);
        }

        var polygons = geometries.OfType<Polygon>();
        if (polygons.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, polygons);
        }
    }

    private async Task DataSource_RemoveAsync(string id, IEnumerable<string> geometryIds) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceRemove.ToAzureMapsControlNamespace(), id, geometryIds);
    private async Task DataSource_ClearAsync(string dataSourceId) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceClear.ToAzureMapsControlNamespace(), dataSourceId);

    #endregion

    #region Drawing Toolbar

    private async Task DrawingToolbarEventReceivedAsync(AzureMapsControl.Components.Drawing.DrawingToolbarJsEventArgs drawingToolbarEvent)
    {
        switch (drawingToolbarEvent.Type)
        {
            case "drawingchanged":
                await OnDrawingChanged.InvokeAsync(new Drawing.DrawingToolbarEventArgs(MapService.Map, drawingToolbarEvent));
                break;

            case "drawingchanging":
                await OnDrawingChanging.InvokeAsync(new Drawing.DrawingToolbarEventArgs(MapService.Map, drawingToolbarEvent));
                break;

            case "drawingcomplete":
                await OnDrawingComplete.InvokeAsync(new Drawing.DrawingToolbarEventArgs(MapService.Map, drawingToolbarEvent));
                break;

            case "drawingmodechanged":
                await OnDrawingModeChanged.InvokeAsync(new Drawing.DrawingToolbarModeEventArgs(MapService.Map, drawingToolbarEvent));
                break;

            case "drawingstarted":
                await OnDrawingStarted.InvokeAsync(new MapEventArgs(MapService.Map, drawingToolbarEvent.Type));
                break;
        }
    }

    private async Task AddDrawingToolbarAsync(AzureMapsControl.Components.Drawing.DrawingToolbarOptions drawingToolbarOptions)
    {
        if (drawingToolbarOptions != null)
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddDrawingToolbar.ToAzureMapsControlNamespace(),
            new AzureMapsControl.Components.Drawing.DrawingToolbarCreationOptions
            {
                Buttons = drawingToolbarOptions.Buttons?.Select(button => button.ToString()).ToArray(),
                ContainerId = drawingToolbarOptions.ContainerId,
                DragHandleStyle = drawingToolbarOptions.DragHandleStyle,
                FreehandInterval = drawingToolbarOptions.FreehandInterval,
                InteractionType = drawingToolbarOptions.InteractionType.ToString(),
                Mode = drawingToolbarOptions.Mode.ToString(),
                NumColumns = drawingToolbarOptions.NumColumns,
                Position = drawingToolbarOptions.Position.ToString(),
                SecondaryDragHandleStyle = drawingToolbarOptions.SecondaryDragHandleStyle,
                ShapeDraggingEnabled = drawingToolbarOptions.ShapesDraggingEnabled,
                Style = drawingToolbarOptions.Style.ToString(),
                Visible = drawingToolbarOptions.Visible,
                Events = drawingToolbarOptions.Events?.EnabledEvents
            },
            DotNetObjectReference.Create(_drawingToolbarEventInvokeHelper));
        }
    }

    private async Task UpdateDrawingToolbarAsync(AzureMapsControl.Components.Drawing.DrawingToolbarUpdateOptions drawingToolbarOptions)
    {
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodUpdateDrawingToolbar.ToAzureMapsControlNamespace(),
        new AzureMapsControl.Components.Drawing.DrawingToolbarCreationOptions
        {
            Buttons = drawingToolbarOptions.Buttons?.Select(button => button.ToString()).ToArray(),
            ContainerId = drawingToolbarOptions.ContainerId,
            NumColumns = drawingToolbarOptions.NumColumns,
            Position = drawingToolbarOptions.Position.ToString(),
            Style = drawingToolbarOptions.Style.ToString(),
            Visible = drawingToolbarOptions.Visible
        });
    }

    private async Task RemoveDrawingToolbarAsync() => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodRemoveDrawingToolbar.ToAzureMapsControlNamespace());

    #endregion

    #region HTML Markers

    private async Task HtmlMarkerEventReceivedAsync(AzureMapsControl.Components.Markers.HtmlMarkerJsEventArgs htmlMarkerEvent)
    {
        if (MapService.Map.HtmlMarkers != null)
        {
            var htmlMarker = MapService.Map.HtmlMarkers.First(marker => marker.Id == htmlMarkerEvent.MarkerId);
            if (htmlMarker != null)
            {
                await Task.Run(() =>
                {
                    htmlMarker.DispatchEvent(MapService.Map, htmlMarkerEvent.Type);
                });
            }
        }
    }

    private async Task ClearHtmlMarkersAsync() => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearHtmlMarkers.ToAzureMapsControlNamespace());

    private async Task AddHtmlMarkersAsync(IEnumerable<AzureMapsControl.Components.Markers.HtmlMarker> htmlMarkers)
    {
        var newHtmlMarkers = htmlMarkers?.Where(marker => marker != null);
        if (newHtmlMarkers != null && newHtmlMarkers.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddHtmlMarkers.ToAzureMapsControlNamespace(),
            newHtmlMarkers.Select(marker => new AzureMapsControl.Components.Markers.HtmlMarkerCreationOptions
            {
                Id = marker.Id,
                Events = marker.EventActivationFlags?.EnabledEvents,
                Options = marker.Options
            }),
            DotNetObjectReference.Create(_htmlMarkerEventInvokeHelper));
        }
    }

    private async Task RemoveHtmlMarkersAsync(IEnumerable<AzureMapsControl.Components.Markers.HtmlMarker> htmlMarkers)
    {
        var htmlMarkersToRemove = htmlMarkers?.Where(marker => marker != null && Guid.TryParse(marker.Id, out _));
        if (htmlMarkersToRemove.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodRemoveHtmlMarkers.ToAzureMapsControlNamespace(), htmlMarkersToRemove.Select(marker => marker.Id));
        }
    }

    private async Task UpdateHtmlMarkersAsync(IEnumerable<AzureMapsControl.Components.Markers.HtmlMarkerUpdate> updates)
    {
        var htmlMarkersToUpdate = updates?.Where(htmlMarker => htmlMarker?.Marker != null && htmlMarker.Options != null);
        if (htmlMarkersToUpdate != null && htmlMarkersToUpdate.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodUpdateHtmlMarkers.ToAzureMapsControlNamespace(),
            htmlMarkersToUpdate.Select(update => new AzureMapsControl.Components.Markers.HtmlMarkerCreationOptions
            {
                Id = update.Marker.Id,
                Options = update.Options
            }));
        }
    }

    #endregion

    #region Layers

    private async Task LayerEventReceivedAsync(MapJsEventArgs eventArgs)
    {
        var layer = MapService.Map.Layers.FirstOrDefault(l => l.Id == eventArgs.LayerId);
        if (layer != null)
        {
            await Task.Run(() =>
            {
                layer.DispatchEvent(MapService.Map, eventArgs);
            });
        }
    }

    private async Task ClearLayersAsync() => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearLayers.ToAzureMapsControlNamespace());

    private async Task AddLayerAsync(AzureMapsControl.Components.Layers.Layer layer, string before)
    {
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddLayer.ToAzureMapsControlNamespace(),
            layer.Id,
            before,
            layer.Type.ToString(),
            layer.GetLayerOptions()?.GenerateJsOptions(),
            layer.EventActivationFlags.EnabledEvents,
            DotNetObjectReference.Create(_layerEventInvokeHelper));
    }

    private async Task RemoveLayersAsync(IEnumerable<string> layerIds) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodRemoveLayers.ToAzureMapsControlNamespace(), layerIds);

    #endregion

    #region Map

    private async Task MapEventReceivedAsync(MapJsEventArgs mapEvent)
    {
        if (mapEvent.Type == "ready")
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodSetOptions.ToAzureMapsControlNamespace(),
                CameraOptions,
                StyleOptions,
                UserInteractionOptions,
                TrafficOptions);

            await MapService.AddMapAsync(new Map(Id,
                AddControlsAsync,
                AddHtmlMarkersAsync,
                UpdateHtmlMarkersAsync,
                RemoveHtmlMarkersAsync,
                AddDrawingToolbarAsync,
                UpdateDrawingToolbarAsync,
                RemoveDrawingToolbarAsync,
                AddLayerAsync,
                RemoveLayersAsync,
                AddSourceAsync,
                RemoveSourceAsync,
                AttachDataSourcesCallback,
                ClearMapAsync,
                ClearLayersAsync,
                ClearSourcesAsync,
                ClearHtmlMarkersAsync,
                AddPopupAsync,
                Popup_RemoveAsync,
                ClearPopupsAsync,
                SetCameraOptionsAsync,
                SetStyleOptionsAsync,
                SetUserInteractionAsync,
                SetTrafficAsync)
            {
                Controls = Controls,
                HtmlMarkers = HtmlMarkers,
                DrawingToolbarOptions = DrawingToolbarOptions,
                CameraOptions = CameraOptions,
                StyleOptions = StyleOptions,
                UserInteractionOptions = UserInteractionOptions,
                TrafficOptions = TrafficOptions
            });

            await AddControlsAsync(Controls);
            await AddHtmlMarkersAsync(HtmlMarkers);
            await AddDrawingToolbarAsync(DrawingToolbarOptions);
        }
        await DispatchMapEventAsync(mapEvent);
    }

    private async Task SetCameraOptionsAsync(CameraOptions options) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodSetCameraOptions.ToAzureMapsControlNamespace(), options);

    private async Task SetStyleOptionsAsync(StyleOptions options) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodSetStyleOptions.ToAzureMapsControlNamespace(), options);

    private async Task SetUserInteractionAsync(UserInteractionOptions options) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodSetUserInteraction.ToAzureMapsControlNamespace(), options);

    private async Task SetTrafficAsync(AzureMapsControl.Components.Traffic.TrafficOptions options) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodSetTraffic.ToAzureMapsControlNamespace(), options);

    private async Task ClearMapAsync() => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearMap.ToAzureMapsControlNamespace());

    private async Task DispatchMapEventAsync(MapJsEventArgs mapEvent)
    {
        if (EventActivationFlags != null
        && EventActivationFlags.EnabledEvents != null
        && EventActivationFlags.EnabledEvents.Contains(mapEvent.Type))
        {
            switch (mapEvent.Type)
            {
                case "boxzoomend":
                    await OnBoxZoomEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "boxzoomstart":
                    await OnBoxZoomStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "click":
                    await OnClick.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "contextmenu":
                    await OnContextMenu.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "data":
                    await OnData.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "dblclick":
                    await OnDblClick.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "drag":
                    await OnDrag.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "dragend":
                    await OnDragEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "dragstart":
                    await OnDragStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "error":
                    await OnError.InvokeAsync(new MapErrorEventArgs(MapService.Map, mapEvent));
                    break;
                case "idle":
                    await OnIdle.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "layeradded":
                    await OnLayerAdded.InvokeAsync(new MapLayerEventArgs(MapService.Map, mapEvent));
                    break;
                case "layerremoved":
                    await OnLayerRemoved.InvokeAsync(new MapLayerEventArgs(MapService.Map, mapEvent));
                    break;
                case "load":
                    await OnLoad.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "mousedown":
                    await OnMouseDown.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "mousemove":
                    await OnMouseMove.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "mouseout":
                    await OnMouseOut.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "mouseover":
                    await OnMouseOver.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "mouseup":
                    await OnMouseUp.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "move":
                    await OnMove.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "moveend":
                    await OnMoveEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "movestart":
                    await OnMoveStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "pitch":
                    await OnPitch.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "pitchend":
                    await OnPitchEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "pitchstart":
                    await OnPitchStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "ready":
                    await OnReady.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "render":
                    await OnRender.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "resize":
                    await OnResize.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "rotate":
                    await OnRotate.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "rotateend":
                    await OnRotateEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "rotatestart":
                    await OnRotateStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "sourceadded":
                    await OnSourceAdded.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "sourcedate":
                    await OnSourceData.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "sourceremoved":
                    await OnSourceRemoved.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "styledata":
                    await OnStyleData.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "styleimagemissing":
                    await OnStyleImageMissing.InvokeAsync(new MapMessageEventArgs(MapService.Map, mapEvent));
                    break;
                case "tokenacquired":
                    await OnTokenAcquired.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "touchcancel":
                    await OnTouchCancel.InvokeAsync(new MapTouchEventArgs(MapService.Map, mapEvent));
                    break;
                case "touchend":
                    await OnTouchEnd.InvokeAsync(new MapTouchEventArgs(MapService.Map, mapEvent));
                    break;
                case "touchmove":
                    await OnTouchMove.InvokeAsync(new MapTouchEventArgs(MapService.Map, mapEvent));
                    break;
                case "touchstart":
                    await OnTouchStart.InvokeAsync(new MapTouchEventArgs(MapService.Map, mapEvent));
                    break;
                case "wheel":
                    await OnWheel.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "zoom":
                    await OnZoom.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "zoomend":
                    await OnZoomEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "zoomstart":
                    await OnZoomStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
            }
        }
    }

    #endregion

    #region Popups

    private async Task AddPopupAsync(AzureMapsControl.Components.Popups.Popup popup)
    {
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddPopup.ToAzureMapsControlNamespace(), popup.Id, popup.Options, popup.EventActivationFlags.EnabledEvents, DotNetObjectReference.Create(_popupInvokeHelper));
        popup.OpenPopupCallback = Popup_OpenAsync;
        popup.ClosePopupCallback = Popup_CloseAsync;
        popup.RemoveCallback = Popup_RemoveAsync;
        popup.UpdateCallback = Popup_UpdateAsync;
    }

    private async Task Popup_OpenAsync(string id) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodPopupOpen.ToAzureMapsControlNamespace(), id);
    private async Task Popup_CloseAsync(string id) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodPopupClose.ToAzureMapsControlNamespace(), id);
    private async Task Popup_RemoveAsync(string id)
    {
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodPopupRemove.ToAzureMapsControlNamespace(), id);
        MapService.Map.RemovePopup(id);
    }
    private async Task Popup_UpdateAsync(string id, AzureMapsControl.Components.Popups.PopupOptions options) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodPopupUpdate.ToAzureMapsControlNamespace(), id, options);
    private async Task ClearPopupsAsync() => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearPopups.ToAzureMapsControlNamespace());

    private async Task PopupEventReceivedAsync(AzureMapsControl.Components.Popups.PopupEventArgs eventArgs) => 
        await Task.Run(() => MapService.Map.Popups.First(popup => popup.Id == eventArgs.Id).DispatchEvent(eventArgs));

    #endregion
}
