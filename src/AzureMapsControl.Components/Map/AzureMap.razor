@namespace AzureMapsControl.Components.Map

@using AzureMapsControl.Components.Atlas
@using AzureMapsControl.Components.Configuration

@using Microsoft.JSInterop
@using Microsoft.Extensions.Options

@inject IOptions<AzureMapsConfiguration> Configuration
@inject IMapAdderService MapService
@inject IJSRuntime JSRuntime

<div id="@Id"></div>

@code {

    #region Fields

    private MapEventInvokeHelper _mapEventInvokeHelper;
    private Markers.HtmlMarkerInvokeHelper _htmlMarkerEventInvokeHelper;
    private Drawing.DrawingToolbarEventInvokeHelper _drawingToolbarEventInvokeHelper;
    private Layers.LayerEventInvokeHelper _layerEventInvokeHelper;

    private string _id;

    #endregion

    #region Parameters

    /// <summary>
    /// If true the map will automatically resize whenever the window's size changes. Otherwise map.resize() must be called.
    /// Default true.
    /// </summary>
    [Parameter]
    public bool AutoResize { get; set; } = true;

    /// <summary>
    /// The bearing of the map (rotation).
    /// default: North
    /// </summary>
    [Parameter]
    public Bearing Bearing { get; set; } = Bearing.North;

    /// <summary>
    /// The bounds of the map control's camera
    /// </summary>
    [Parameter]
    public BoundingBox Bounds { get; set; }

    /// <summary>
    /// Whether the Shift + left click and drag will draw a zoom box. default true
    /// </summary>
    [Parameter]
    public bool BoxZoomInteraction { get; set; } = true;

    /// <summary>
    /// The type of animation.
    /// "jump" is an immediate change.
    /// "ease" is a gradual change of the camera's settings.
    /// "fly" is a gradual change of the camera's settings following an arc resembling flight.
    /// </summary>
    [Parameter]
    public CameraType CameryType { get; set; }

    /// <summary>
    /// The position to align the center of the map view with
    /// </summary>
    [Parameter]
    public Position Center { get; set; }

    /// <summary>
    /// A pixel offset to apply to the center of the map.
    /// This is useful if you want to programmatically pan the map to another location or if you want to center the map over a shape, then offset the maps view to make room for a popup.
    /// </summary>
    [Parameter]
    public Pixel CenterOffset { get; set; }

    /// <summary>
    /// Whether double left click will zoom the map inwards. Default true
    /// </summary>
    [Parameter]
    public bool DblclickZoomInteraction { get; set; } = true;

    /// <summary>
    /// Disable telemetry collection
    /// This option may only be set when initializing the map.
    /// default: false
    /// </summary>
    [Parameter]
    public bool DisableTelemetry { get; set; }

    /// <summary>
    /// Whether left click and drag will pan the map. default true
    /// </summary>
    [Parameter]
    public bool DragPanInteraction { get; set; } = true;

    /// <summary>
    /// Whether right click and drag will rotate and pitch the map. default true
    /// </summary>
    [Parameter]
    public bool DragRotateInteraction { get; set; } = true;

    /// <summary>
    /// The duration of the animation in milliseconds.
    /// </summary>
    [Parameter]
    public int? Duration { get; set; }

    /// <summary>
    /// Enable accessibility
    /// default: true
    /// </summary>
    [Parameter]
    public bool EnableAccessibility { get; set; } = true;

    /// <summary>
    /// Whether the map is interactive or static. If false, all user interaction is disabled. If true, only selected user interactions will enabled. default true
    /// </summary>
    [Parameter]
    public bool Interactive { get; set; } = true;

    /// <summary>
    /// Whether the keyboard interactions are enabled. Default true
    /// </summary>
    [Parameter]
    public bool KeyboardInteraction { get; set; } = true;

    /// <summary>
    /// The language of the map labels.
    /// </summary>
    [Parameter]
    public string Language { get; set; }

    /// <summary>
    /// Sets the lighting options of the map.
    /// </summary>
    [Parameter]
    public LightOptions Light { get; set; }

    /// <summary>
    /// Id affected to the div hosting the map
    /// </summary>
    [Parameter]
    public string Id
    {
        get => _id;
        set { if (string.IsNullOrWhiteSpace(value)) { throw new ArgumentException("ID on the map is mandatory"); } _id = value; }
    }

    /// <summary>
    /// A bounding box in which to constrain the viewable map area to. Users won't be able to pan the center of the map outside of this bounding box. Set maxBounds to null or undefined to remove maxBounds
    /// </summary>
    [Parameter]
    public BoundingBox MaxBounds { get; set; }

    /// <summary>
    /// The maximum zoom level that the map can be zoomed into during the animation. Must be between 0 and 24, and greater than or equal to `minZoom`.
    /// </summary>
    [Parameter]
    public int? MaxZoom { get; set; }

    /// <summary>
    /// The minimum zoom level that the map can be zoomed out to during the animation. Must be between 0 and 24, and less than or equal to `maxZoom`.
    /// </summary>
    [Parameter]
    public int? MinZoom { get; set; }

    /// <summary>
    /// An offset of the center of the given bounds relative to the map's center, measured in pixels
    /// </summary>
    [Parameter]
    public Pixel Offset { get; set; }

    /// <summary>
    /// The amount of padding in pixels to add to the given bounds
    /// </summary>
    [Parameter]
    public Padding Padding { get; set; }

    /// <summary>
    /// The pitch (tilt) of the map in degrees between 0 and 60, where 0 is looking straight down on the map.
    /// </summary>
    [Parameter]
    public int? Pitch { get; set; }

    /// <summary>
    /// If true, the map's canvas can be exported to a PNG using map.getCanvas().toDataURL().
    /// </summary>
    [Parameter]
    public bool PreserveDrawingBuffer { get; set; }

    /// <summary>
    /// A boolean that specifies if vector and raster tiles should be reloaded when they expire (based on expires header).
    /// This is useful for data sets that update frequently. When set to false, each tile will be loaded once, when needed, and not reloaded when they expire.
    /// default: true
    /// <summary>
    [Parameter]
    public bool RefreshExpiredTiles { get; set; } = true;

    /// <summary>
    /// Specifies if multiple copies of the world should be rendered when zoomed out. Default true
    /// </summary>
    [Parameter]
    public bool RenderWorldCopies { get; set; } = true;

    /// <summary>
    /// Whether the map should zoom on scroll input. default true
    /// </summary>
    [Parameter]
    public bool ScrollZoomInteraction { get; set; } = true;

    /// <summary>
    /// Specifies if buildings will be rendered with their models. If false all buildings will be rendered as just their footprints
    /// </summary>
    [Parameter]
    public bool ShowBuildingModels { get; set; }

    /// <summary>
    /// Specifies if the feedback link should be displayed on the map or not. Default true
    /// </summary>
    [Parameter]
    public bool ShowFeedbackLink { get; set; } = true;

    /// <summary>
    /// Specifies if the Microsoft logo should be hidden or not. If set to true a Microsoft copyright string will be added to the map. Default true
    /// </summary>
    [Parameter]
    public bool ShowLogo { get; set; } = true;

    /// <summary>
    /// Specifies if the map should render an outline around each tile and the tile ID. These tile boundaries are useful for debugging. The uncompressed file size of the first vector source is drawn in the top left corner of each tile, next to the tile ID
    /// </summary>
    [Parameter]
    public bool ShowTilesBoundaries { get; set; }

    /// <summary>
    /// The name of the style to use when rendering the map
    /// </summary>
    [Parameter]
    public string Style { get; set; }

    /// <summary>
    /// Whether touch interactions are enabled for touch devices. default true
    /// </summary>
    [Parameter]
    public bool TouchInteraction { get; set; }

    /// <summary>
    /// Specifies which set of geopolitically disputed borders and labels are displayed on the map. The View parameter (also referred to as “user region parameter”) is a 2-letter ISO-3166 Country Code that will show the correct maps for that country/region. Country/Regions that are not on the View list or if unspecified will default to the “Unified” View
    /// </summary>
    [Parameter]
    public string View { get; set; }

    /// <summary>
    /// Sets the zoom rate of the mouse wheel default 1/450
    /// </summary>
    [Parameter]
    public double WheelZoomRate { get; set; }

    /// <summary>
    /// The zoom level of the map view
    /// </summary>
    [Parameter]
    public int? Zoom { get; set; }

    /// <summary>
    /// Defines the events which needs to be activated
    /// </summary>
    [Parameter]
    public MapEventActivationFlags EventActivationFlags { get; set; }

    /// <summary>
    /// Defines the controls to add to the map when it is ready
    /// </summary>
    [Parameter]
    public IReadOnlyCollection<Control> Controls { get; set; }

    /// <summary>
    /// HtmlMarkers to add to the map when it is ready
    /// </summary>
    [Parameter]
    public IReadOnlyCollection<AzureMapsControl.Components.Markers.HtmlMarker> HtmlMarkers { get; set; }

    /// <summary>
    /// Options to display traffic on the map
    /// </summary>
    [Parameter]
    public AzureMapsControl.Components.Traffic.TrafficOptions TrafficOptions { get; set; }

    /// <summary>
    /// Options to display a drawing toolbar on the map
    /// </summary>
    [Parameter]
    public AzureMapsControl.Components.Drawing.DrawingToolbarOptions DrawingToolbarOptions { get; set; }

    /// <summary>
    /// Fired when a "box zoom" interaction ends.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnBoxZoomEnd { get; set; }

    /// <summary>
    /// Fired when a "box zoom" interaction starts.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnBoxZoomStart { get; set; }

    /// <summary>
    /// Fired when a pointing device is pressed and released at the same point on the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnClick { get; set; }

    /// <summary>
    /// Fired when the right button of the mouse is clicked.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnContextMenu { get; set; }

    /// <summary>
    /// Fired when any map data loads or changes.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnData { get; set; }

    /// <summary>
    /// Fired when a pointing device is clicked twice at the same point on the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnDblClick { get; set; }

    /// <summary>
    /// Fired repeatedly during a "drag to pan" interaction on the map, popup, or HTML marker.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnDrag { get; set; }

    /// <summary>
    /// Fired when a "drag to pan" interaction ends on the map, popup, or HTML marker.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnDragEnd { get; set; }

    /// <summary>
    /// Fired when a "drag to pan" interaction starts on the map, popup, or HTML marker.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnDragStart { get; set; }

    /// <summary>
    /// Fired when an error occurs.
    /// </summary>
    [Parameter]
    public EventCallback<MapErrorEventArgs> OnError { get; set; }

    /// <summary>
    /// Fired after the last frame rendered before the map enters an "idle" state:
    /// No camera transitions are in progress.
    /// All currently requested tiles have loaded.
    /// All fade/transition animations have completed.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnIdle { get; set; }

    /// <summary>
    /// Fired after a layer has been added to the map
    /// </summary>
    [Parameter]
    public EventCallback<MapLayerEventArgs> OnLayerAdded { get; set; }

    /// <summary>
    /// Fired after a layer has been removed from the map
    /// </summary>
    [Parameter]
    public EventCallback<MapLayerEventArgs> OnLayerRemoved { get; set; }

    /// <summary>
    /// Fired immediately after all necessary resources have been downloaded and the first visually complete rendering of the map has occurred.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnLoad { get; set; }

    /// <summary>
    /// Fired when a pointing device is pressed within the map or when on top of an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseDown { get; set; }

    /// <summary>
    /// Fired when a pointing device is moved within the map or an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseMove { get; set; }

    /// <summary>
    /// Fired when a point device leaves the map's canvas our leaves an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseOut { get; set; }

    /// <summary>
    /// Fired when a pointing device is moved over the map or an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseOver { get; set; }

    /// <summary>
    /// Fired when a pointing device is released within the map or when on top of an element.
    /// </summary>
    [Parameter]
    public EventCallback<MapMouseEventArgs> OnMouseUp { get; set; }

    /// <summary>
    /// Fired repeatedly during an animated transition from one view to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnMove { get; set; }

    /// <summary>
    /// Fired just after the map completes a transition from one view to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnMoveEnd { get; set; }

    /// <summary>
    /// Fired just before the map begins a transition from one view to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnMoveStart { get; set; }

    /// <summary>
    /// Fired whenever the map's pitch (tilt) changes as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnPitch { get; set; }

    /// <summary>
    /// Fired immediately after the map's pitch (tilt) finishes changing as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnPitchEnd { get; set; }

    /// <summary>
    /// Fired whenever the map's pitch (tilt) begins a change as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnPitchStart { get; set; }

    /// <summary>
    /// Fired when the minimum required map resources are loaded before the map is ready to be programmatically interacted with.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnReady { get; set; }

    /// <summary>
    /// Fired whenever the map is drawn to the screen, as the result of:
    /// A change to the map's position, zoom, pitch, or bearing.
    /// A change to the map's style.
    /// A change to a DataSource source.
    /// The loading of a vector tile, GeoJSON file, glyph, or sprite.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnRender { get; set; }

    /// <summary>
    /// Fired immediately after the map has been resized.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnResize { get; set; }

    /// <summary>
    /// Fired repeatedly during a "drag to rotate" interaction.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnRotate { get; set; }

    /// <summary>
    /// Fired when a "drag to rotate" interaction ends.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnRotateEnd { get; set; }

    /// <summary>
    /// Fired when a "drag to rotate" interaction starts.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnRotateStart { get; set; }

    /// <summary>
    /// Fired when a DataSource or VectorTileSource is added to the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnSourceAdded { get; set; }

    /// <summary>
    /// Fired when one of the map's sources loads or changes, including if a tile belonging to a source loads or changes.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnSourceData { get; set; }

    /// <summary>
    /// Fired when a DataSource or VectorTileSource is removed from the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnSourceRemoved { get; set; }

    /// <summary>
    /// Fired when the map's style loads or changes.
    /// </summary>
    [Parameter]
    public EventCallback<MapDataEventArgs> OnStyleData { get; set; }

    /// <summary>
    /// Fired when a layer tries to load an image from the image sprite that doesn't exist
    /// </summary>
    [Parameter]
    public EventCallback<MapMessageEventArgs> OnStyleImageMissing { get; set; }

    /// <summary>
    /// Fired when an AAD access token is obtained.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnTokenAcquired { get; set; }

    /// <summary>
    /// Fired when a touchcancel event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapTouchEventArgs> OnTouchCancel { get; set; }

    /// <summary>
    /// Fired when a touchend event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapTouchEventArgs> OnTouchEnd { get; set; }

    /// <summary>
    /// Fired when a touchmove event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapTouchEventArgs> OnTouchMove { get; set; }

    /// <summary>
    /// Fired when a touchstart event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapTouchEventArgs> OnTouchStart { get; set; }

    /// <summary>
    /// Fired when a mouse wheel event occurs within the map.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnWheel { get; set; }

    /// <summary>
    /// Fired repeatedly during an animated transition from one zoom level to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnZoom { get; set; }

    /// <summary>
    /// Fired just after the map completes a transition from one zoom level to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnZoomEnd { get; set; }

    /// <summary>
    /// Fired just before the map begins a transition from one zoom level to another, as the result of either user interaction or methods.
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnZoomStart { get; set; }

    /// <summary>
    /// Fired when the drawing mode has changed on the drawing toolbar
    /// </summary>
    [Parameter]
    public EventCallback<AzureMapsControl.Components.Drawing.DrawingToolbarModeEventArgs> OnDrawingModeChanged { get; set; }

    /// <summary>
    /// Fired when a drawing has started
    /// </summary>
    [Parameter]
    public EventCallback<MapEventArgs> OnDrawingStarted { get; set; }

    /// <summary>
    /// Fired repeatedly when a drawing is changing
    /// </summary>
    [Parameter]
    public EventCallback<AzureMapsControl.Components.Drawing.DrawingToolbarEventArgs> OnDrawingChanging { get; set; }

    /// <summary>
    /// Fired when a drawing has changed
    /// </summary>
    [Parameter]
    public EventCallback<AzureMapsControl.Components.Drawing.DrawingToolbarEventArgs> OnDrawingChanged { get; set; }

    /// <summary>
    /// Fires when a drawing is completed
    /// </summary>
    [Parameter]
    public EventCallback<AzureMapsControl.Components.Drawing.DrawingToolbarEventArgs> OnDrawingComplete { get; set; }

    #endregion

    #region Razor events

    protected override void OnInitialized()
    {
        _mapEventInvokeHelper = new MapEventInvokeHelper(MapEventReceivedAsync);
        _htmlMarkerEventInvokeHelper = new Markers.HtmlMarkerInvokeHelper(HtmlMarkerEventReceivedAsync);
        _drawingToolbarEventInvokeHelper = new Drawing.DrawingToolbarEventInvokeHelper(DrawingToolbarEventReceivedAsync);
        _layerEventInvokeHelper = new Layers.LayerEventInvokeHelper(LayerEventReceivedAsync);
        base.OnInitialized();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddMap.ToAzureMapsControlNamespace(),
                Id,
                Configuration.Value.AuthType,
                Configuration.Value.AadAppId,
                Configuration.Value.AadTenant,
                Configuration.Value.ClientId,
                Configuration.Value.SubscriptionKey,
                new ServiceOptions
                {
                    DisableTelemetry = DisableTelemetry,
                    EnableAccessibility = EnableAccessibility,
                    RefreshExpiredTiles = RefreshExpiredTiles
                },
                (EventActivationFlags ?? MapEventActivationFlags.None().Enable(MapEventType.Ready)).EnabledEvents,
                DotNetObjectReference.Create(_mapEventInvokeHelper));
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    #endregion

    #region Controls

    private async Task AddControlsAsync(IEnumerable<Control> controls)
    {
        var newControls = controls?.Where(control => control != null);
        if (newControls != null && newControls.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddControl.ToAzureMapsControlNamespace(),
            newControls.Select(control => new ControlOptions
            {
                Type = control.Type.ToString(),
                Position = control.Position.ToString()
            }));
        }
    }

    #endregion

    #region Data sources

    private async Task ClearSourcesAsync() => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearSources.ToAzureMapsControlNamespace());

    private async Task AddSourceAsync(AzureMapsControl.Components.Data.Source source) =>
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddSource.ToAzureMapsControlNamespace(), source.Id, source.GetSourceOptions()?.GenerateJsOptions(), source.SourceType.ToString());

    private void AttachDataSourcesCallback(AzureMapsControl.Components.Data.DataSource dataSource)
    {
        dataSource.ImportDataFromUrlCallback = DataSource_ImportDataFromUrlAsync;
        dataSource.AddCallback = DataSource_AddAsync;
        dataSource.RemoveCallback = DataSource_RemoveAsync;
        dataSource.ClearCallback = DataSource_ClearAsync;
    }

    private async Task RemoveSourceAsync(string dataSourceId) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodRemoveSource.ToAzureMapsControlNamespace(), dataSourceId);

    private async Task DataSource_ImportDataFromUrlAsync(string id, string url) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceImportDataFromUrl.ToAzureMapsControlNamespace(), id, url);

    private async Task DataSource_AddAsync(string id, IEnumerable<Geometry> geometries)
    {
        var lineStrings = geometries.OfType<LineString>();
        if (lineStrings.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, lineStrings);
        }

        var multiLineStrings = geometries.OfType<MultiLineString>();
        if (multiLineStrings.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, multiLineStrings);
        }

        var multiPoints = geometries.OfType<MultiPoint>();
        if (multiPoints.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, multiPoints);
        }

        var multiPolygons = geometries.OfType<MultiPolygon>();
        if (multiPolygons.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, multiPolygons);
        }

        var points = geometries.OfType<Point>();
        if (points.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, points);
        }

        var polygons = geometries.OfType<Polygon>();
        if (polygons.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceAdd.ToAzureMapsControlNamespace(), id, polygons);
        }
    }

    private async Task DataSource_RemoveAsync(string id, IEnumerable<string> geometryIds) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceRemove.ToAzureMapsControlNamespace(), id, geometryIds);
    private async Task DataSource_ClearAsync(string dataSourceId) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodDataSourceClear.ToAzureMapsControlNamespace(), dataSourceId);

    #endregion

    #region Drawing Toolbar

    private async Task DrawingToolbarEventReceivedAsync(AzureMapsControl.Components.Drawing.DrawingToolbarJsEventArgs drawingToolbarEvent)
    {
        switch (drawingToolbarEvent.Type)
        {
            case "drawingchanged":
                await OnDrawingChanged.InvokeAsync(new Drawing.DrawingToolbarEventArgs(MapService.Map, drawingToolbarEvent));
                break;

            case "drawingchanging":
                await OnDrawingChanging.InvokeAsync(new Drawing.DrawingToolbarEventArgs(MapService.Map, drawingToolbarEvent));
                break;

            case "drawingcomplete":
                await OnDrawingComplete.InvokeAsync(new Drawing.DrawingToolbarEventArgs(MapService.Map, drawingToolbarEvent));
                break;

            case "drawingmodechanged":
                await OnDrawingModeChanged.InvokeAsync(new Drawing.DrawingToolbarModeEventArgs(MapService.Map, drawingToolbarEvent));
                break;

            case "drawingstarted":
                await OnDrawingStarted.InvokeAsync(new MapEventArgs(MapService.Map, drawingToolbarEvent.Type));
                break;
        }
    }

    private async Task AddDrawingToolbarAsync(AzureMapsControl.Components.Drawing.DrawingToolbarOptions drawingToolbarOptions)
    {
        if (drawingToolbarOptions != null)
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddDrawingToolbar.ToAzureMapsControlNamespace(),
            new AzureMapsControl.Components.Drawing.DrawingToolbarCreationOptions
            {
                Buttons = drawingToolbarOptions.Buttons?.Select(button => button.ToString()).ToArray(),
                ContainerId = drawingToolbarOptions.ContainerId,
                DragHandleStyle = drawingToolbarOptions.DragHandleStyle,
                FreehandInterval = drawingToolbarOptions.FreehandInterval,
                InteractionType = drawingToolbarOptions.InteractionType.ToString(),
                Mode = drawingToolbarOptions.Mode.ToString(),
                NumColumns = drawingToolbarOptions.NumColumns,
                Position = drawingToolbarOptions.Position.ToString(),
                SecondaryDragHandleStyle = drawingToolbarOptions.SecondaryDragHandleStyle,
                ShapeDraggingEnabled = drawingToolbarOptions.ShapesDraggingEnabled,
                Style = drawingToolbarOptions.Style.ToString(),
                Visible = drawingToolbarOptions.Visible,
                Events = drawingToolbarOptions.Events?.EnabledEvents
            },
            DotNetObjectReference.Create(_drawingToolbarEventInvokeHelper));
        }
    }

    private async Task UpdateDrawingToolbarAsync(AzureMapsControl.Components.Drawing.DrawingToolbarUpdateOptions drawingToolbarOptions)
    {
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodUpdateDrawingToolbar.ToAzureMapsControlNamespace(),
        new AzureMapsControl.Components.Drawing.DrawingToolbarCreationOptions
        {
            Buttons = drawingToolbarOptions.Buttons?.Select(button => button.ToString()).ToArray(),
            ContainerId = drawingToolbarOptions.ContainerId,
            NumColumns = drawingToolbarOptions.NumColumns,
            Position = drawingToolbarOptions.Position.ToString(),
            Style = drawingToolbarOptions.Style.ToString(),
            Visible = drawingToolbarOptions.Visible
        });
    }

    private async Task RemoveDrawingToolbarAsync() => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodRemoveDrawingToolbar.ToAzureMapsControlNamespace());

    #endregion

    #region HTML Markers

    private async Task HtmlMarkerEventReceivedAsync(AzureMapsControl.Components.Markers.HtmlMarkerJsEventArgs htmlMarkerEvent)
    {
        if (MapService.Map.HtmlMarkers != null)
        {
            var htmlMarker = MapService.Map.HtmlMarkers.First(marker => marker.Id == htmlMarkerEvent.MarkerId);
            if (htmlMarker != null)
            {
                await Task.Run(() =>
                {
                    htmlMarker.DispatchEvent(MapService.Map, htmlMarkerEvent.Type);
                });
            }
        }
    }

    private async Task ClearHtmlMarkersAsync() => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearHtmlMarkers.ToAzureMapsControlNamespace());

    private async Task AddHtmlMarkersAsync(IEnumerable<AzureMapsControl.Components.Markers.HtmlMarker> htmlMarkers)
    {
        var newHtmlMarkers = htmlMarkers?.Where(marker => marker != null);
        if (newHtmlMarkers != null && newHtmlMarkers.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddHtmlMarkers.ToAzureMapsControlNamespace(),
            newHtmlMarkers.Select(marker => new AzureMapsControl.Components.Markers.HtmlMarkerCreationOptions
            {
                Id = marker.Id,
                Events = marker.EventActivationFlags?.EnabledEvents,
                Options = marker.Options
            }),
            DotNetObjectReference.Create(_htmlMarkerEventInvokeHelper));
        }
    }

    private async Task RemoveHtmlMarkersAsync(IEnumerable<AzureMapsControl.Components.Markers.HtmlMarker> htmlMarkers)
    {
        var htmlMarkersToRemove = htmlMarkers?.Where(marker => marker != null && Guid.TryParse(marker.Id, out _));
        if (htmlMarkersToRemove.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodRemoveHtmlMarkers.ToAzureMapsControlNamespace(), htmlMarkersToRemove.Select(marker => marker.Id));
        }
    }

    private async Task UpdateHtmlMarkersAsync(IEnumerable<AzureMapsControl.Components.Markers.HtmlMarkerUpdate> updates)
    {
        var htmlMarkersToUpdate = updates?.Where(htmlMarker => htmlMarker?.Marker != null && htmlMarker.Options != null);
        if (htmlMarkersToUpdate != null && htmlMarkersToUpdate.Any())
        {
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodUpdateHtmlMarkers.ToAzureMapsControlNamespace(),
            htmlMarkersToUpdate.Select(update => new AzureMapsControl.Components.Markers.HtmlMarkerCreationOptions
            {
                Id = update.Marker.Id,
                Options = update.Options
            }));
        }
    }

    #endregion

    #region Layers

    private async Task LayerEventReceivedAsync(MapJsEventArgs eventArgs)
    {
        var layer = MapService.Map.Layers.FirstOrDefault(l => l.Id == eventArgs.LayerId);
        if (layer != null)
        {
            await Task.Run(() =>
            {
                layer.DispatchEvent(MapService.Map, eventArgs);
            });
        }
    }

    private async Task ClearLayersAsync() => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearLayers.ToAzureMapsControlNamespace());

    private async Task AddLayerAsync(AzureMapsControl.Components.Layers.Layer layer, string before)
    {
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddLayer.ToAzureMapsControlNamespace(),
            layer.Id,
            before,
            layer.Type.ToString(),
            layer.GetLayerOptions()?.GenerateJsOptions(),
            layer.EventActivationFlags.EnabledEvents,
            DotNetObjectReference.Create(_layerEventInvokeHelper));
    }

    private async Task RemoveLayersAsync(IEnumerable<string> layerIds) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodRemoveLayers.ToAzureMapsControlNamespace(), layerIds);

    #endregion

    #region Map

    private async Task MapEventReceivedAsync(MapJsEventArgs mapEvent)
    {
        if (mapEvent.Type == "ready")
        {
            var cameraOptions = new CameraOptions
            {
                Bearing = (int?)Bearing,
                CenterOffset = CenterOffset,
                Duration = Duration,
                MaxZoom = MaxZoom,
                MinZoom = MinZoom,
                Pitch = Pitch,
                Type = CameryType?.ToString(),
                Bounds = Bounds,
                MaxBounds = Bounds != null ? MaxBounds : null,
                Offset = Bounds != null ? Offset : null,
                Padding = Bounds != null ? Padding : null,
                Center = Bounds == null ? Center : null,
                Zoom = Bounds == null ? Zoom : null
            };
            await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodSetOptions.ToAzureMapsControlNamespace(),
                cameraOptions,
                new StyleOptions
                {
                    AutoResize = AutoResize,
                    Language = Language,
                    Light = Light,
                    PreserveDrawingBuffer = PreserveDrawingBuffer,
                    RenderWorldCopies = RenderWorldCopies,
                    ShowBuildingModels = ShowBuildingModels,
                    ShowFeedbackLink = ShowFeedbackLink,
                    ShowLogo = ShowLogo,
                    ShowTileBoundaries = ShowTilesBoundaries,
                    Style = Style,
                    View = View
                },
                new UserInteractionOptions
                {
                    BoxZoomInteraction = BoxZoomInteraction,
                    DblclickZoomInteraction = DblclickZoomInteraction,
                    DragPanInteraction = DragPanInteraction,
                    DragRotateInteraction = DragRotateInteraction,
                    Interactive = Interactive,
                    KeyboardInteraction = KeyboardInteraction,
                    ScrollZoomInteraction = ScrollZoomInteraction,
                    TouchInteraction = TouchInteraction,
                    WheelZoomRate = WheelZoomRate
                },
                TrafficOptions != null ? new AzureMapsControl.Components.Traffic.TrafficJsOptions
                {
                    Flow = (TrafficOptions.Flow ?? AzureMapsControl.Components.Traffic.TrafficFlow.None).ToString(),
                    Incidents = TrafficOptions.Incidents
                } : null);

            await MapService.AddMapAsync(new Map(Id,
                AddControlsAsync,
                AddHtmlMarkersAsync,
                UpdateHtmlMarkersAsync,
                RemoveHtmlMarkersAsync,
                AddDrawingToolbarAsync,
                UpdateDrawingToolbarAsync,
                RemoveDrawingToolbarAsync,
                AddLayerAsync,
                RemoveLayersAsync,
                AddSourceAsync,
                RemoveSourceAsync,
                AttachDataSourcesCallback,
                ClearMapAsync,
                ClearLayersAsync,
                ClearSourcesAsync,
                ClearHtmlMarkersAsync,
                AddPopupAsync,
                Popup_RemoveAsync,
                ClearPopupsAsync,
                SetCameraOptionsAsync)
            {
                Controls = Controls,
                HtmlMarkers = HtmlMarkers,
                DrawingToolbarOptions = DrawingToolbarOptions,
                CameraOptions = cameraOptions
            });

            await AddControlsAsync(Controls);
            await AddHtmlMarkersAsync(HtmlMarkers);
            await AddDrawingToolbarAsync(DrawingToolbarOptions);
        }
        await DispatchMapEventAsync(mapEvent);
    }

    private async Task SetCameraOptionsAsync(CameraOptions options) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodSetCameraOptions.ToAzureMapsControlNamespace(), options);

    private async Task ClearMapAsync() => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearMap.ToAzureMapsControlNamespace());

    private async Task DispatchMapEventAsync(MapJsEventArgs mapEvent)
    {
        if (EventActivationFlags != null
        && EventActivationFlags.EnabledEvents != null
        && EventActivationFlags.EnabledEvents.Contains(mapEvent.Type))
        {
            switch (mapEvent.Type)
            {
                case "boxzoomend":
                    await OnBoxZoomEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "boxzoomstart":
                    await OnBoxZoomStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "click":
                    await OnClick.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "contextmenu":
                    await OnContextMenu.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "data":
                    await OnData.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "dblclick":
                    await OnDblClick.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "drag":
                    await OnDrag.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "dragend":
                    await OnDragEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "dragstart":
                    await OnDragStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "error":
                    await OnError.InvokeAsync(new MapErrorEventArgs(MapService.Map, mapEvent));
                    break;
                case "idle":
                    await OnIdle.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "layeradded":
                    await OnLayerAdded.InvokeAsync(new MapLayerEventArgs(MapService.Map, mapEvent));
                    break;
                case "layerremoved":
                    await OnLayerRemoved.InvokeAsync(new MapLayerEventArgs(MapService.Map, mapEvent));
                    break;
                case "load":
                    await OnLoad.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "mousedown":
                    await OnMouseDown.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "mousemove":
                    await OnMouseMove.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "mouseout":
                    await OnMouseOut.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "mouseover":
                    await OnMouseOver.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "mouseup":
                    await OnMouseUp.InvokeAsync(new MapMouseEventArgs(MapService.Map, mapEvent));
                    break;
                case "move":
                    await OnMove.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "moveend":
                    await OnMoveEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "movestart":
                    await OnMoveStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "pitch":
                    await OnPitch.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "pitchend":
                    await OnPitchEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "pitchstart":
                    await OnPitchStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "ready":
                    await OnReady.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "render":
                    await OnRender.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "resize":
                    await OnResize.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "rotate":
                    await OnRotate.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "rotateend":
                    await OnRotateEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "rotatestart":
                    await OnRotateStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "sourceadded":
                    await OnSourceAdded.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "sourcedate":
                    await OnSourceData.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "sourceremoved":
                    await OnSourceRemoved.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "styledata":
                    await OnStyleData.InvokeAsync(new MapDataEventArgs(MapService.Map, mapEvent));
                    break;
                case "styleimagemissing":
                    await OnStyleImageMissing.InvokeAsync(new MapMessageEventArgs(MapService.Map, mapEvent));
                    break;
                case "tokenacquired":
                    await OnTokenAcquired.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "touchcancel":
                    await OnTouchCancel.InvokeAsync(new MapTouchEventArgs(MapService.Map, mapEvent));
                    break;
                case "touchend":
                    await OnTouchEnd.InvokeAsync(new MapTouchEventArgs(MapService.Map, mapEvent));
                    break;
                case "touchmove":
                    await OnTouchMove.InvokeAsync(new MapTouchEventArgs(MapService.Map, mapEvent));
                    break;
                case "touchstart":
                    await OnTouchStart.InvokeAsync(new MapTouchEventArgs(MapService.Map, mapEvent));
                    break;
                case "wheel":
                    await OnWheel.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "zoom":
                    await OnZoom.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "zoomend":
                    await OnZoomEnd.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
                case "zoomstart":
                    await OnZoomStart.InvokeAsync(new MapEventArgs(MapService.Map, mapEvent.Type));
                    break;
            }
        }
    }

    #endregion

    #region Popups

    private async Task AddPopupAsync(AzureMapsControl.Components.Popups.Popup popup)
    {
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodAddPopup.ToAzureMapsControlNamespace(), popup.Id, popup.Options);
        popup.OpenPopupCallback = Popup_OpenAsync;
        popup.ClosePopupCallback = Popup_CloseAsync;
        popup.RemoveCallback = Popup_RemoveAsync;
        popup.UpdateCallback = Popup_UpdateAsync;
    }

    private async Task Popup_OpenAsync(string id) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodPopupOpen.ToAzureMapsControlNamespace(), id);
    private async Task Popup_CloseAsync(string id) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodPopupClose.ToAzureMapsControlNamespace(), id);
    private async Task Popup_RemoveAsync(string id)
    {
        await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodPopupRemove.ToAzureMapsControlNamespace(), id);
        MapService.Map.RemovePopup(id);
    }
    private async Task Popup_UpdateAsync(string id, AzureMapsControl.Components.Popups.PopupOptions options) => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodPopupUpdate.ToAzureMapsControlNamespace(), id, options);
    private async Task ClearPopupsAsync() => await JSRuntime.InvokeVoidAsync(Constants.JsConstants.MethodClearPopups.ToAzureMapsControlNamespace());

    #endregion
}
